name: kOps Cluster Deployment

on:
  pull_request:
    branches: [ "main" ]
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      cluster_name:
        description: 'Short name of the cluster (will auto-append .k8s.local)'
        required: true
        type: string
        default: 'dev-cluster'
      master_nodes:
        description: 'Number of master nodes'
        required: true
        default: '1'
        type: choice
        options:
          - '1'
          - '2'

      master_size:
        description: 'Size of master nodes'
        required: true
        default: 't2.medium'
        type: choice
        options:
          - 't2.small'
          - 't2.medium'
          - 't2.large'
      worker_nodes:
        description: 'Number of worker nodes'
        required: true
        default: '2'
        type: choice
        options:
          - '2'
          - '3'
      worker_size:
        description: 'Size of worker nodes'
        required: true
        default: 't2.small'
        type: choice
        options:
          - 't2.micro'
          - 't2.small'
          - 't2.medium'
      duration:
        description: 'Duration of the deployment'
        required: true
        default: '2h'
        type: choice
        options:
          - '2h'
          - '4h'
          - '8h'
          - '12h'
env:
  TF_VERSION: 1.7.0

jobs:
  kops-infra:
    name: kOps Infrastructure & Cluster Deployment
    runs-on: ubuntu-latest

    steps:
      - name: Validate and Set Cluster Name
        run: |
          # Use defaults for push/PR events, inputs for manual dispatch
          CLUSTER_INPUT="${{ github.event.inputs.cluster_name || 'dev-cluster' }}"
          ENVIRONMENT="${{ github.event.inputs.environment || 'dev' }}"
          
          # Validate cluster name format (alphanumeric and hyphens only)
          if [[ ! "$CLUSTER_INPUT" =~ ^[a-z0-9-]+$ ]]; then
            echo "‚ùå Cluster name must contain only lowercase letters, numbers, and hyphens"
            exit 1
          fi
          
          # Auto-append .k8s.local if not present
          if [[ "$CLUSTER_INPUT" == *.k8s.local ]]; then
            FULL_CLUSTER_NAME="$CLUSTER_INPUT"
          else
            FULL_CLUSTER_NAME="${CLUSTER_INPUT}.k8s.local"
          fi
          
          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
          echo "VALIDATED_CLUSTER_NAME=$FULL_CLUSTER_NAME" >> $GITHUB_ENV
          echo "‚úÖ Event: ${{ github.event_name }}"
          echo "‚úÖ Environment: $ENVIRONMENT"
          echo "‚úÖ Cluster name: $FULL_CLUSTER_NAME"
      - name: Checkout Repo
        uses: actions/checkout@v3

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}
          terraform_wrapper: false

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}
      
      - name: Validate IAM Permissions
        run: |
          set -e
          echo "üîç Validating IAM permissions for kOps cluster creation..."
          
          # Test critical permissions required by kOps
          PERMISSIONS_VALID=true
          
          # Test EC2 permissions
          if ! aws ec2 describe-regions --region ${{ vars.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå Missing EC2 permissions"
            PERMISSIONS_VALID=false
          fi
          
          # Test S3 permissions (for state store)
          if ! aws s3 ls s3://${{ vars.TF_STATE_BUCKET }}/ >/dev/null 2>&1; then
            echo "‚ùå Missing S3 permissions or bucket access"
            PERMISSIONS_VALID=false
          fi
          
          # Test IAM permissions
          if ! aws iam get-user >/dev/null 2>&1; then
            echo "‚ùå Missing IAM permissions"
            PERMISSIONS_VALID=false
          fi
          
          # Test Route53 permissions
          if ! aws route53 list-hosted-zones >/dev/null 2>&1; then
            echo "‚ùå Missing Route53 permissions"
            PERMISSIONS_VALID=false
          fi
          
          # Test Auto Scaling permissions
          if ! aws autoscaling describe-auto-scaling-groups --region ${{ vars.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå Missing Auto Scaling permissions"
            PERMISSIONS_VALID=false
          fi
          
          # Test ELB permissions
          if ! aws elbv2 describe-load-balancers --region ${{ vars.AWS_REGION }} >/dev/null 2>&1; then
            echo "‚ùå Missing ELB permissions"
            PERMISSIONS_VALID=false
          fi
          
          if [ "$PERMISSIONS_VALID" = "false" ]; then
            echo "‚ùå IAM user lacks required permissions for kOps cluster creation"
            echo "Required permissions: EC2, S3, IAM, Route53, Auto Scaling, ELB, CloudWatch, RDS"
            echo "Please ensure the IAM user has the kOps admin policy attached"
            exit 1
          fi
          echo "‚úÖ IAM permissions validated successfully"

      - name: Get Available Zones
        run: |
          ZONES=$(aws ec2 describe-availability-zones \
            --region ${{ vars.AWS_REGION }} \
            --filters "Name=state,Values=available" \
            --query "AvailabilityZones[0:3].ZoneName" \
            --output text | tr '\t' ',') || { echo "Failed to get zones"; exit 1; }
          
          if [[ -z "$ZONES" ]]; then
            echo "No available zones found"
            exit 1
          fi
          
          echo "AVAILABLE_ZONES=$ZONES" >> $GITHUB_ENV
          echo "‚úÖ Available zones: $ZONES"

      - name: Install kOps and kubectl
        run: |
          set -e
          
          KOPS_VERSION=$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4) || { echo "Failed to get kOps version"; exit 1; }
          curl -Lo kops "https://github.com/kubernetes/kops/releases/download/${KOPS_VERSION}/kops-linux-amd64" || { echo "Failed to download kOps"; exit 1; }
          chmod +x kops && sudo mv kops /usr/local/bin/ || { echo "Failed to install kOps"; exit 1; }
          
          KUBECTL_VERSION=$(curl -L -s https://dl.k8s.io/release/stable.txt) || { echo "Failed to get kubectl version"; exit 1; }
          curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" || { echo "Failed to download kubectl"; exit 1; }
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/ || { echo "Failed to install kubectl"; exit 1; }
          
          echo "‚úÖ Tools installed successfully"
      - name: SSH Key Setup
        if: ${{ github.event_name != 'pull_request' }}
        run: |
          set -e
          mkdir -p ~/.ssh || { echo "Failed to create .ssh directory"; exit 1; }
          rm -f ~/.ssh/id_rsa ~/.ssh/id_rsa.pub
          ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa -N "" || { echo "Failed to generate SSH key"; exit 1; }
          eval "$(ssh-agent -s)" || { echo "Failed to start SSH agent"; exit 1; }
          ssh-add ~/.ssh/id_rsa || { echo "Failed to add SSH key"; exit 1; }
          echo "‚úÖ SSH key setup completed"
      - name: Check Cluster Existence
        if: ${{ github.event_name != 'pull_request' }}
        run: |
          export KOPS_STATE_STORE=s3://${{ vars.TF_STATE_BUCKET }}/$ENVIRONMENT/clusters/
          export CLUSTER_NAME=$VALIDATED_CLUSTER_NAME
          echo "KOPS_STATE_STORE=$KOPS_STATE_STORE" >> $GITHUB_ENV
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          
          if kops get cluster --name=$CLUSTER_NAME --state=$KOPS_STATE_STORE >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Cluster $CLUSTER_NAME already exists"
            echo "CLUSTER_EXISTS=true" >> $GITHUB_ENV
          else
            echo "‚úÖ Cluster $CLUSTER_NAME does not exist, proceeding with creation"
            echo "CLUSTER_EXISTS=false" >> $GITHUB_ENV
          fi
          
      - name: kOps Cluster Initialization
        if: ${{ github.event_name != 'pull_request' && env.CLUSTER_EXISTS == 'false' }}
        run: |
          set -e
          export ZONES=$AVAILABLE_ZONES

          kops create sshpublickey $CLUSTER_NAME -i ~/.ssh/id_rsa.pub --state=$KOPS_STATE_STORE || { echo "Failed to create SSH public key"; exit 1; }

          kops create cluster \
            --name=$CLUSTER_NAME \
            --state=$KOPS_STATE_STORE \
            --zones=$ZONES \
            --node-count="${{ github.event.inputs.worker_nodes || '2' }}" \
            --node-size="${{ github.event.inputs.worker_size || 't2.small' }}" \
            --master-size="${{ github.event.inputs.master_size || 't2.medium' }}" \
            --master-count="${{ github.event.inputs.master_nodes || '1' }}" \
            --networking=calico \
            --dns-zone=$CLUSTER_NAME \
            --ssh-public-key="~/.ssh/id_rsa.pub" || { echo "Failed to create cluster configuration"; exit 1; }
          
          echo "‚úÖ Cluster configuration created"

      - name: kOps Cluster Update
        if: ${{ github.event_name != 'pull_request' }}
        run: |
          set -e
          if [ "$CLUSTER_EXISTS" = "true" ]; then
            echo "‚ö†Ô∏è  Using existing cluster configuration"
          fi
          
          kops update cluster \
            --name=$CLUSTER_NAME \
            --state=$KOPS_STATE_STORE \
            --yes \
            --admin \
            --out ./kops-infra \
            --target terraform || { echo "Failed to generate Terraform files"; exit 1; }
          
          echo "‚úÖ Terraform files generated"
      - name: Create backend.tf file
        if: ${{ github.event_name != 'pull_request' }}
        working-directory: ./kops-infra
        run: |
          cat > backend.tf << EOF
          terraform {
            backend "s3" {
              bucket = "${{ vars.TF_STATE_BUCKET }}"
              key    = "$ENVIRONMENT/kops-infra/$VALIDATED_CLUSTER_NAME"
              region = "${{ vars.AWS_REGION }}"
            }
          }
          EOF
          
      - name: Terraform Init
        if: ${{ github.event_name != 'pull_request' }}
        working-directory: ./kops-infra
        run: |
          set -e
          terraform init || { echo "Terraform init failed"; exit 1; }
          echo "‚úÖ Terraform initialized"
        
      - name: Terraform Plan
        if: ${{ github.event_name != 'pull_request' }}
        working-directory: ./kops-infra
        run: |
          set -e
          terraform plan -out=tfplan || { echo "Terraform plan failed"; exit 1; }
          echo "‚úÖ Terraform plan completed"
      - name: Terraform Apply
        if: ${{ github.event_name == 'push' }}
        working-directory: ./kops-infra
        run: |
          set -e
          terraform apply -auto-approve tfplan || { echo "Terraform apply failed"; exit 1; }
          echo "‚úÖ Infrastructure deployed"
          
      - name: Dry Run Summary
        if: ${{ github.event_name == 'pull_request' }}
        run: |
          echo "üß™ DRY RUN COMPLETED"
          echo "Event: ${{ github.event_name }}"
          echo "Cluster name: $VALIDATED_CLUSTER_NAME"
          echo "Environment: $ENVIRONMENT"
          echo "‚úÖ Infrastructure validation successful"
      - name: Validate Cluster
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          set -e
          echo "‚è≥ Exporting kubeconfig..."
          kops export kubeconfig \
            --name="$VALIDATED_CLUSTER_NAME" \
            --state="$KOPS_STATE_STORE" \
            --admin || { echo "Failed to export kubeconfig"; exit 1; }
          
          echo "‚è≥ Waiting for cluster to be ready..."
          kops validate cluster \
            --name="$VALIDATED_CLUSTER_NAME" \
            --state="$KOPS_STATE_STORE" \
            --wait=10m || { echo "Cluster validation failed"; exit 1; }
          
          echo "‚úÖ Cluster is ready"
            
      - name: Generate and Share kubeconfig
        if: ${{ github.event_name == 'workflow_dispatch' }}
        run: |
          set -e
          echo "‚è≥ Testing cluster access..."
          kubectl get nodes || { echo "Failed to get nodes"; exit 1; }
          kubectl get namespaces || { echo "Failed to get namespaces"; exit 1; }
          
          # Store kubeconfig for team access
          BUCKET="${{ vars.TF_STATE_BUCKET }}"
          aws s3 cp ~/.kube/config "s3://$BUCKET/$ENVIRONMENT/$VALIDATED_CLUSTER_NAME/kubeconfig" || { echo "Failed to upload kubeconfig"; exit 1; }
          
          echo "‚úÖ Cluster deployed successfully!"
          echo "üìã Cluster: $VALIDATED_CLUSTER_NAME"
          echo "üîó Access: aws s3 cp s3://$BUCKET/$ENVIRONMENT/$VALIDATED_CLUSTER_NAME/kubeconfig ~/.kube/config"

  cleanup:
    name: Cleanup Test Cluster
    runs-on: ubuntu-latest
    needs: kops-infra
    if: ${{ github.event_name != 'workflow_dispatch' && needs.kops-infra.result == 'success' }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.7.0
          terraform_wrapper: false

      - name: Install kOps
        run: |
          KOPS_VERSION=$(curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d '"' -f 4)
          curl -Lo kops "https://github.com/kubernetes/kops/releases/download/${KOPS_VERSION}/kops-linux-amd64"
          chmod +x kops && sudo mv kops /usr/local/bin/
          echo "‚úÖ kOps installed"

      - name: Set Cleanup Variables
        run: |
          CLUSTER_NAME="dev-cluster.k8s.local"
          ENVIRONMENT="dev"
          KOPS_STATE_STORE="s3://${{ vars.TF_STATE_BUCKET }}/$ENVIRONMENT/clusters/"
          
          echo "CLUSTER_NAME=$CLUSTER_NAME" >> $GITHUB_ENV
          echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
          echo "KOPS_STATE_STORE=$KOPS_STATE_STORE" >> $GITHUB_ENV
          echo "üßπ Cleaning up test cluster: $CLUSTER_NAME"

      - name: Wait Before Cleanup
        run: |
          echo "‚è≥ Waiting 2 minutes before cleanup to allow testing..."
          sleep 120

      - name: Terraform Destroy
        continue-on-error: true
        working-directory: ./kops-infra
        run: |
          # Recreate backend.tf for cleanup
          cat > backend.tf << EOF
          terraform {
            backend "s3" {
              bucket = "${{ vars.TF_STATE_BUCKET }}"
              key    = "$ENVIRONMENT/kops-infra/$CLUSTER_NAME"
              region = "${{ vars.AWS_REGION }}"
            }
          }
          EOF
          
          if terraform init; then
            terraform destroy -auto-approve
            echo "‚úÖ Terraform resources destroyed"
          else
            echo "‚ö†Ô∏è  Terraform state not found, proceeding with kOps cleanup"
          fi

      - name: kOps Cluster Destroy
        continue-on-error: true
        run: |
          if kops get cluster --name=$CLUSTER_NAME --state=$KOPS_STATE_STORE >/dev/null 2>&1; then
            echo "üóëÔ∏è  Deleting cluster $CLUSTER_NAME..."
            kops delete cluster --name=$CLUSTER_NAME --state=$KOPS_STATE_STORE --yes
            echo "‚úÖ Cluster deleted"
          else
            echo "‚ÑπÔ∏è  Cluster $CLUSTER_NAME not found, already cleaned up"
          fi

      - name: Cleanup S3 Artifacts
        continue-on-error: true
        run: |
          echo "üßπ Cleaning up S3 artifacts..."
          aws s3 rm "s3://${{ vars.TF_STATE_BUCKET }}/$ENVIRONMENT/$CLUSTER_NAME/" --recursive
          aws s3 rm "s3://${{ vars.TF_STATE_BUCKET }}/$ENVIRONMENT/kops-infra/$CLUSTER_NAME/" --recursive
          echo "‚úÖ S3 cleanup completed"

      - name: Cleanup Summary
        run: |
          echo "üßπ CLEANUP COMPLETED"
          echo "Event: ${{ github.event_name }}"
          echo "Cluster: $CLUSTER_NAME"
          echo "Environment: $ENVIRONMENT"
          echo "‚úÖ Test resources cleaned up successfully"
  